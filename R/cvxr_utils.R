#'Generate decision variable for convex power optimization 
#' @description
#' generates a binary vector which represents the weight function used by CVXR
#' for power optimization.
#' 
#' @param opts$Nfine the number of points in the underlying fine grid from which 
#' measurement times are to be chosen.
#'   
#' @return \code{x} binary [CVXR::Variable] to be used as the decision variable in CVXR programming.
#' @author Turner Silverthorne
#' @export
make_variable=function(opts){
  x=Variable(opts$Nfine,boolean=T)
  return(x)
}

#' Generate matrices for quadratic forms used in convex power optimization
#' 
#' @param opts$Nfine number of points in the fine time grid
#' @param opts$Nfreq number of frequencies in frequency grid
#' @param opts$Nmeas measurement budget
#' @param opts$fmin minimum frequency to be included
#' @param opts$fmax maximum frequency to be included
#' 
#' @return a list of matrices of length \code{opts$Nfreq}. Each entry in the list 
#' corresponds to a quadratic form at a frequency between \code{opts$fmin} and 
#' \code{opts$fmax}.
#' 
#' @author Turner Silverthorne
#' @export
make_quadmats = function(opts,...){
  Nfine   = opts$Nfine
  Nfreq   = opts$Nfreq
  Nmeas   = opts$Nmeas
  fmin    = opts$fmin
  fmax    = opts$fmax
  
  tau   = (0:Nfine)/Nfine       
  tau   = tau[1:(length(tau)-1)] 
  fvec  = seq(from=fmin,to=fmax,length.out=Nfreq)
  
  Amlist = list() 
  for (ii in c(1:Nfreq)){
    freq  = fvec[ii]
    cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
    svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
    
    a11   = cvec*cvec
    a22   = svec*svec
    a12   = cvec*svec
    
    Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
    
    Amlist[[ii]]=Amat 
    
  }

  return(Amlist)  
}

#' Generate a convex programming problem equivalent to power optimization
#' 
#' @description
#' generates a disciplined convex programming problem equivalent to maximizing 
#' the statistical power of a cosinor-based hypothesis test. The problem is created 
#' as a [CVXR::Problem()] which can then be solved using [CVXR] together with the 
#' [GUROBI] backend. The [GUROBI] backend is necessary because there are integer
#' constraints on the problem.
#' 
#' @param x a [CVXR::Variable()] representing the weight function for measurement times, see [make_variable()]
#' @param Aquad a list of symmetric matrices generated by [make_quadmats]
#' @param opts$lattice_cstr must be equal to \code{'none'} for function to evaluate 
#' @param opts$optim_method must be equal to \code{'cvxr'} for function to evaluate 
#' 
#' @return \code{prob} a disciplined convex programming problem [CVXR::Problem] 
#' which can be solved using the [CVXR] library. 
#' 
#' @author Turner Silverthorne
#' @export
make_problem=function(x,Aquad,opts,regL1=0,regFder=0,...){
  # convert to CVXR datatype
  for (ii in c(1:length(Aquad))){
    Aquad[[ii]]=Constant(Aquad[[ii]])
  }
  
  Nm   = Constant(opts$Nmeas)
  csts = list( sum(x) == Nm)
  big_str = paste(lapply(1:length(Aquad) %>% as.list(),
         function(ind){
           paste0('quad_form(x,Aquad[[',ind,']])')
         }),collapse=',')
 
  str_prefix='prob=Problem(Minimize('
  str_suffix=paste0('max_elemwise(',big_str,')),csts)')
  
  if(regL1>0){
    regL1 = Constant(regL1)  
    str_prefix=paste0(str_prefix,'regL1*quad_form(x,Amean)+')
  }
  if(regFder>0){
    stop('freq regularization not yet implemented for CVXR')
  }
  
  strp=paste0(str_prefix,str_suffix)
  eval(parse(text=strp))
  return(prob)
}

make_problem_entries=function(x,Aquad,opts){
  Nm   = Constant(opts$Nmeas)
  csts = list( sum(x) == Nm)
  for (ii in c(1:length(Aquad))){
    if (ii == 1){
      obj = quad_form(x,Constant(Aquad[[ii]]))
    }
    obj = vstack(obj,quad_form(x,Constant(Aquad[[ii]])))
  }
  
  prob = Problem(Minimize(max_entries(obj)),csts)
}


make_problem_hvolume=function(x,Aquad,opts,weight){
  Nm   = Constant(opts$Nmeas)
  csts = list( sum(x) == Nm)
 
  Amean_w= 0
  for (ii in c(1:length(Aquad))){
    Amean_w= Amean_w + Aquad[[ii]]*weight[ii]
  }
  Amean_w=Amean_w/length(Aquad)
  Amean_w=Constant(Amean_w)
 
  
  prob=Problem(Minimize(quad_form(x,Amean_w)),csts)
  return(prob)
}