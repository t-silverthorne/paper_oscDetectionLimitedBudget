#' Generate decision variable for convex power optimization 
#' 
#' @description
#' \code{make_variable()} generates a binary vector which represents the weight function used by CVXR
#' for power optimization.
#' 
#' @param opts optimization options generated by [make_default_opts()]. 
#' * if \code{opts$lattice_cstr=='none'}, \code{x} will have \code{opts$Nfine} components 
#' * if \code{opts$lattice_cstr=='lineq'}, \code{x} will have \code{opts$Nfine} components
#' * if \code{opts$lattice_cstr=='cfun'}, \code{x} will have as many dimensions as there are constraints in \code{Lmat}
#' 
#' In the first two cases, \code{x} represents as a weight function on the candidate measurement times. In the third case,
#' \code{x} represents as a weight function on the candidate sub-lattices.
#' 
#' @param Lmat a matrix containing the lattice constraints, only relevant to this function if \code{opts$lattice_cstr=='cfun'} 
#'   
#' @return \code{x} binary [CVXR::Variable] to be used as the decision variable in CVXR programming.
#' 
#' @author Turner Silverthorne
#' @export
make_variable=function(opts){
  x=Variable(opts$Nfine,boolean=T)
  return(x)
}

#' Generate matrices for quadratic forms used in convex power optimization
#' 
#' @description
#' The output of \code{make_quadmats()} depends on the choice of cost function specified in
#' \code{opts$costfun_type}. If using an L1 cost function, different frequencies will be 
#' averaged over in constructing the output matrix. If using an Linfty cost function, a 
#' list of matrices will be returned, each matrix corresponding to a different frequency 
#' under consideration.
#' 
#' @param opts optimization options, defaults can be generated by [make_default_opts()]
#' @param Lmat NULL by default, lattice inequality matrix generated by [make_ineqmat()]
#' 
#' @return \code{Aquad} a symmetric matrix to be used in constructing the quadratic form(s)
#' to be optimized in the convex programming routine. 
#' 
#' * If using an L1 cost function, the output will be an average of
#' several symmetric matrices, with each matrix corresponding to a candidate frequency of interest.
#' * If using an Linfty cost function, a list of SPD matrices will be returned suitable for a
#' downstream maximin convex programming. 
#' 
#' @author Turner Silverthorne
#' @export
make_quadmats = function(opts,returnFder=F,...){
  Nfine   = opts$Nfine
  Nfreq   = opts$Nfreq
  Nmeas   = opts$Nmeas
  fmin    = opts$fmin
  fmax    = opts$fmax
  
  tau   = (0:Nfine)/Nfine       
  tau   = tau[1:(length(tau)-1)] 
  fvec  = seq(from=fmin,to=fmax,length.out=Nfreq)
  
  # construct freq-discretized list of cfun matrices
  Amlist = list() 
  for (ii in c(1:Nfreq)){
    freq  = fvec[ii]
    cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
    svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
    
    a11   = cvec*cvec
    a22   = svec*svec
    a12   = cvec*svec
    
    Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
    
    Amlist[[ii]]=Amat 
    
  }

  return(Amlist)  
}

#' Generate a convex programming problem equivalent to power optimization
#' 
#' @description
#' \code{make_problem()} generates a disciplined convex programming problem that is
#' equivalent to maximizing the statistical power of a cosinor-based hypothesis test.
#' The problem is created as a [CVXR::Problem()] which can then be solved using [CVXR]
#' together with the [GUROBI] backend. The [GUROBI] backend is necessary because there
#' are integer constraints on the problem.
#' 
#' @param x a [CVXR::Variable()] representing the weight function for measurement times, see [make_variable()]
#' @param Aquad the symmetric matrix/matrices that define the quadratic form to be optimized, see [make_quadmats()]
#' @param csts a list made up of integer and convex constraints on \code{x}, see [make_constraints()]
#' @param opts a complete set of optimization options, default values can be generated by [make_default_opts()] 
#' 
#' @return \code{prob} a disciplined convex programming problem which can be solved using the [CVXR] library. 
#'  *  See [CVXR::Problem()] for more details on this datatype.
#'  
#' @author Turner Silverthorne
#' @export
make_problem=function(x,Aquad,opts,regL1=0,regFder=0,...){
  # get mean of quad mats and convert to CVXR type
  Amean = 0
  for (ii in c(1:length(Aquad))){
    Amean = Amean + Aquad[[ii]]
    Aquad[[ii]]=Constant(Aquad[[ii]])
  }
  Amean = Amean/length(Aquad)
  Amean = Constant(Amean)
  if(opts$lattice_cstr=='none' & opts$optim_method =='cvxr'){
    Nm   = Constant(opts$Nmeas)
    csts = list( sum(x) == Nm)
    big_str = paste(lapply(1:length(Aquad) %>% as.list(),
           function(ind){
             paste0('quad_form(x,Aquad[[',ind,']])')
           }),collapse=',')
   
    str_prefix='prob=Problem(Minimize('
    str_suffix=paste0('max_elemwise(',big_str,')),csts)')
    
    if(regL1>0){
      regL1 = Constant(regL1)  
      str_prefix=paste0(str_prefix,'regL1*quad_form(x,Amean)+')
    }
    if(regFder>0){
      stop('freq regularization not yet implemented for CVXR')
    }
    
    strp=paste0(str_prefix,str_suffix)
    eval(parse(text=strp))
  }else{
    stop('unrecognized opts$lattice_str or opts$solver_type')
  }
  return(prob)
}