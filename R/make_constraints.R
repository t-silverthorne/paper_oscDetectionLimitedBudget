#' Generate CVXR constraints for power optimization
#' 
#' @description
#' \code{make_constraints()} creates a [list()] of constraints to be used by CVXR for power optimization. 
#' 
#' @param x the decision variable for power optimization generated by [make_variable()]
#' @param Lmat matrix of lattice constraints, generated by [make_ineqmat()]
#' @param bvec rowSums of \code{Lmat} generated by [make_ineqvec()]
#' @param opts optimization options, defaults can be generated by [make_default_opts()]
#'
#' @return \code{constraints} a list of constraints to be included when [make_problem()] constructs the optimization problem.
#' 
#' @author Turner Silverthorne
make_constraints=function(x,Lmat,bvec,opts){
  Nm = Constant(opts$Nmeas)
  if (opts$lattice_cstr == 'none'){
    constraints  = list( sum(x) == Nm)
  } else if (opts$lattice_cstr =='lineq'){
    L   = Constant(Lmat) # convert to CVXR class
    b   = bvec-1         # shift trick necessary for constraint
    b   = Constant(b)    # convert to CVXR class
    mla = Constant(opts$max_lat_active) # convert to CVXR class
    constraints = list(sum(x)==Nm,sum(pos(L%*%x - b))<=mla) #TODO: decide if ineq or eq is easier
  }
  else if (opts$lattice_cstr == 'cfun'){
    w   = Constant(bvec)
    mla = Constant(opts$max_lat_active) # convert to CVXR class
    constraints  = list( sum(x) <= mla, t(w)%*%x == Nm) #TODO: decide if ineq or eq is easier 
  } else {
    stop('opts$lattice_cstr not recgonized')    
  }
  return(constraints) 
}