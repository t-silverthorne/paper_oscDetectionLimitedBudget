#' Generate constraints for lattice-constrained power maximization
#'  
#' @description
#' This function generates a matrix of linear constraints that ensure the optimal design can be 
#' decomposed into at most \code{opts$max_lat_active} number of uniform grids.
#' 
#' Imposing these constraints may be useful if one seeks a design that balances performance with convenience of implementation.
#'
#' @param opts optimization options generated by [make_default_opts()].
#' 
#' 
#' @return \code{Lmat} a matrix of linear constraints on the sampling grid
#' * if \code{opts$lattice_cstr=='none'} no lattice constraints are imposed (i.e. \code{Lmat=NULL})
#' * if \code{opts$lattice_cstr=='lineq'}, each row of \code{Lmat} represents a constraint. The constraints will be added to the list of constraints generated by [make_constraints()]
#' * if \code{opts$lattice_cstr=='cfun'}, each column of \code{Lmat} represents a constraint. The constraints will be incorporated in the cost function generated by [make_problem()]
#' 
#' The third option tends to be considerably slower than the second even though they solve equivalent problems. It is
#' incldued here only for benchmarking and reference.
#' 
#' @author Turner Silverthorne
#' @export
make_ineqmat = function(opts){
  #warning('The output of this function is only useful for enforcing lattice constraints in convex programming. It is not very efficient to use convex
  #        programming for this type of problem')
  if (opts$lattice_cstr=='none'){
    Lmat=NULL
  }else if (opts$lattice_cstr=='lineq'|opts$lattice_cstr=='cfun'){
    min_dx  = opts$min_dx
    min_lat = opts$min_lat
    max_lat = opts$max_lat
    Nfine   = opts$Nfine
    
    L=matrix(NA,nrow=0,ncol=Nfine)
    for (npts in c(min_lat:max_lat)){
      dx = min_dx
      x0 = 1
      while (x0 + dx*(npts-1) <= Nfine){
        lat  = seq(from=x0,to=x0+dx*(npts-1),by=dx)
        shift = 0
        while (lat[length(lat)] + shift <= Nfine){
          lat       = lat + shift
          svec      = rep({0},Nfine)
          svec[lat] = 1 
          L         = rbind(L,svec)
          shift     = 1
        }
        dx = dx +1
      }
    }
    Lmat=L
    if (opts$lattice_cstr=='cfun'){
      Lmat=t(Lmat)
    }
  }else{
    stop('Unrecognized lattice constraints.')
  }
  return(Lmat)
}
