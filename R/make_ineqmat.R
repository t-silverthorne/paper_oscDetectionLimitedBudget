#' Generate lattice constraints for convex power optimization
#'  
#' @description
#' This function generates a matrix of linear constraints that ensure the optimal design can be 
#' decomposed into at most \code{opts$max_lat_active} number of uniform grids.
#' 
#' Imposing these constraints may be useful if one seeks a design that balances performance with convenience of implementation.
#'
#' @param opts optimization options generated by [make_default_opts()].
#' * if \code{opts$lattice_cstr=='none'} no lattice constraints are imposed (i.e. \code{Lmat=NULL})
#' * if \code{opts$lattice_cstr=='lineq'}, \code{Lmat} will be added to the constraints generated by [make_constraints()]
#' * if \code{opts$lattice_cstr=='cfun'}, \code{Lmat} will be incorporated in the cost function generated by [make_problem()]
#' 
#' The third option tends to be considerably slower than the second even though they solve equivalent problems. It is
#' incldued here only for benchmarking and reference.
#' 
#' @return \code{Lmat} a matrix where each row corresponds to a linear constraint on the candidate designs
#'
#' @author Turner Silverthorne
make_ineqmat = function(opts){
  Lmat = NaN
  if (opts$lattice_cstr=='none'){
    Lmat=NULL
  }else if (opts$lattice_cstr=='lineq'|opts$lattice_cstr=='cfun'){
    min_dx  = opts$min_dx
    min_lat = opts$min_lat
    max_lat = opts$max_lat
    Nfine   = opts$Nfine
    
    L=matrix(NA,nrow=0,ncol=Nfine)
    for (npts in c(min_lat:max_lat)){
      dx = min_dx
      x0 = 1
      while (x0 + dx*(npts-1) <= Nfine){
        lat  = seq(from=x0,to=x0+dx*(npts-1),by=dx)
        shift = 0
        while (lat[length(lat)] + shift <= Nfine){
          lat       = lat + shift
          svec      = rep({0},Nfine)
          svec[lat] = 1 
          L         = rbind(L,svec)
          shift     = 1
        }
        dx = dx +1
      }
    }
    Lmat = t(L)
  }
  return(Lmat)
}
