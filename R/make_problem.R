#' Generate a convex programming problem equivalent to power optimization
#' 
#' @description
#' \code{make_problem()} generates a disciplined convex programming problem that is
#' equivalent to maximizing the statistical power of a cosinor-based hypothesis test.
#' The problem is created as a [CVXR::Problem()] which can then be solved using [CVXR]
#' together with the [GUROBI] backend. The [GUROBI] backend is necessary because there
#' are integer constraints on the problem.
#' 
#' @param x a [CVXR::Variable()] representing the weight function for measurement times, see [make_variable()]
#' @param Aquad the symmetric matrix/matrices that define the quadratic form to be optimized, see [make_quadmats()]
#' @param csts a list made up of integer and convex constraints on \code{x}, see [make_constraints()]
#' @param opts a complete set of optimization options, default values can be generated by [make_default_opts()] 
#' 
#' @return \code{prob} a disciplined convex programming problem which can be solved using the [CVXR] library. 
#'  *  See [CVXR::Problem()] for more details on this datatype.
#'  
#' @author Turner Silverthorne
make_problem=function(x,Aquad,csts,opts){
  prob = NaN
  if (opts$costfun_type=='L1'){ # L1 uses average of quadratic forms
  
    prob    = Problem(Minimize(quad_form(x,Aquad)),csts)
  
  }else if (opts$costfun_type=='Linfty'){ # Linfty uses maximin formalism
    
    big_str = paste(lapply(1:length(Aquad) %>% as.list(),
           function(ind){
             paste0('quad_form(x,Aquad[[',ind,']])')
           }),collapse=',')
    strp=paste0('prob=Problem(Minimize(max_elemwise(',big_str,')),csts)')
    eval(parse(text=strp))
    
  }
  return(prob)
}