#' Generate matrices for quadratic forms used in convex power optimization
#' 
#' @description
#' The output of \code{make_quadmats()} depends on the choice of cost function specified in
#' \code{opts$costfun_type}. If using an L1 cost function, different frequencies will be 
#' averaged over in constructing the output matrix. If using an Linfty cost function, a 
#' list of matrices will be returned, each matrix corresponding to a different frequency 
#' under consideration.
#' 
#' @param Lmat lattice inequality matrix generated by [make_ineqmat()]
#' @param opts optimization options, defaults can be generated by [make_default_opts()]
#' 
#' @return \code{Aquad} a symmetric matrix to be used in constructing the quadratic form(s)
#' to be optimized in the convex programming routine. 
#' 
#' * If using an L1 cost function, the output will be an average of
#' several symmetric matrices, with each matrix corresponding to a candidate frequency of interest.
#' * If using an Linfty cost function, a list of SPD matrices will be returned suitable for a
#' downstream maximin convex programming. 
#' 
#' @author Turner Silverthorne

make_quadmats = function(Lmat,opts){
  Nfine   = opts$Nfine
  Nfreq   = opts$Nfreq
  Nmeas   = opts$Nmeas
  fmin    = opts$fmin
  fmax    = opts$fmax
  
  tau   = (0:Nfine)/Nfine       
  tau   = tau[1:(length(tau)-1)] 
  fvec  = seq(from=fmin,to=fmax,length.out=Nfreq)
  
  # construct freq-discretized list of cfun matrices
  Amlist = list() 
  for (ii in c(1:Nfreq)){
    freq  = fvec[ii]
    cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
    svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
    
    a11   = cvec*cvec
    a22   = svec*svec
    a12   = cvec*svec
    Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
    
    Amlist[[ii]]=Amat
  }

  # need to conjugate Amlist by Lmat if putting lattice constraints in cost function
  if (opts$lattice_cstr=='cfun'){
    for (ii in c(1:length(Amlist))){
      Amlist[[ii]] = t(Lmat)%*%Amlist[[ii]]%*%Lmat
    }
  }
 
  # return either average of SPD matrices or list of SPD matrices
  Aquad=NaN
  if (opts$costfun_type=='L1'){
    Aquad = 0
    for (ii in c(1:length(Amlist))){
      Aquad = Aquad + Amlist[[ii]]/Nfreq
    }
  }else if(opts$costfun_type=='Linfty'){
    for (ii in c(1:length(Amlist))){
      Amlist[[ii]]=Constant(Amlist[[ii]])
    }
    Aquad=Amlist
  }
  return(Aquad)  
}