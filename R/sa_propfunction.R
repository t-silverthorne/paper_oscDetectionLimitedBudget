#' State proposal function for simulated annealing power maximization
#' 
#' @description
#' Randomly generate new state for power maximization using simulated annealing.
#' You will most likely not need to use this function directly, it is called 
#' by the function [run_sa_power()]
#' 
#' @param x state of system on current iteration of simulated annealing
#' @param opts simulation options, can be generated by [make_default_opts()]
#'
#' @return \code{y} the new state of the system. Procedure for generating \code{y}
#' from input \code{x} depends on whether or not lattice constraints are imposed.
#' * if \code{opts$lattice_cstr='none'} then \code{y} is obtained from \code{x} by randomly
#' swapping an active entry of \code{x} with an inactive entry of \code{x} 
#' * if \code{opts$lattice_cstr='sa_lattice'}, then \code{x} should be interpreted as a 
#' superposition of lattices. A subset of the active lattices L' in L is selected at random to be
#' turned off. If there is a total of \code{n} points in this lattice, a partition of \code{n}
#' is chosen at random and a new set of uniform lattices consistent with this partition replaces
#' the original L' lattices.
#' 
#' @author Turner Silverthorne
sa_propfunction=function(opts,x){
  if (opts$lattice_cstr=='none'){
    y           = x
    swap_on     = sample(which(x==0),1)       # proposed state differs from x at one index
    swap_off    = sample(which(x>0),1)
    y[swap_on]  = 1
    y[swap_off] = 0
  } else if(opts$lattice_cstr=='sa_lattice'){
    stop("sa_lattice transition function has not been implemented yet")
    
    # random subset of current state
    
    # random partition
    
    # random lattice for each element of partition
    
    # update current lattice
  } else {
    stop('choice of lattice constraint not recognized, are you using CVXR option by mistake')
  }
  return(y)
}