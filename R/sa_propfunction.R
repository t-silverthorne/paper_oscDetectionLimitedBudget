#' State proposal function for simulated annealing power maximization
#' 
#' @description
#' Randomly generate new state for power maximization using simulated annealing.
#' You will most likely not need to use this function directly, it is called 
#' by the function [run_sa_power()]
#' 
#' @param x state of system on current iteration of simulated annealing
#' @param opts simulation options, can be generated by [make_default_opts()]
#'
#' @return \code{y} the new state of the system. Procedure for generating \code{y}
#' from input \code{x} depends on whether or not lattice constraints are imposed.
#' * if \code{opts$lattice_cstr='none'} then \code{y} is obtained from \code{x} by randomly
#' swapping an active entry of \code{x} with an inactive entry of \code{x} 
#' * if \code{opts$lattice_cstr='sa_lattice'}, then \code{x} should be interpreted as a 
#' superposition of lattices. A subset of the active lattices L' in L is selected at random to be
#' turned off. If there is a total of \code{n} points in this lattice, a partition of \code{n}
#' is chosen at random and a new set of uniform lattices consistent with this partition replaces
#' the original L' lattices.
#' 
#' @author Turner Silverthorne
sa_propfunction=function(opts,x=NULL){
  if (opts$lattice_cstr=='none'){
    #TODO: add initialization
    y           = x
    swap_on     = sample(which(x==0),1)       # proposed state differs from x at one index
    swap_off    = sample(which(x>0),1)
    y[swap_on]  = 1
    y[swap_off] = 0
  } else if(opts$lattice_cstr=='sa_lattice'){
    if (is.null(x)){
      min_al = opts$min_active_lats
      if (opts$max_active_lats=='adapt'){
        max_al = floor(opts$Nmeas/opts$min_lat)
      }else{
        stop('unrecognized opts$max_active_lats')
      }
      part = sa_randpar(opts$Nmeas) #TODO: check partition is allowable
      x    = list()
    }else{
      #TODO add optional weighting for this
      inds   = sample(c(1:length(x)),sample(1:length(x),1)) # choose how many lattices to update
      xp     = x[inds]
      nsamps = xp %>% lapply(function(x){sum(x)}) %>% unlist() %>% sum()
      part   = sa_randpar(nsamps)#TODO: check partition is allowable
    }
    
    #TODO random lattice for each element of partition
    xnew = list()
    for (pp in c(1:length(part))){
      # random shift
      xnew[[pp]] = sa_randlattice(part[pp],opts)
      # random spacing
    }
    xnew 
    
    #TODO update current lattice
    if (length(x)==0){
      y=xnew
    }else{
      y = append(x[!(c(1:length(x)) %in% inds)],xnew) 
    }
  } else {
    stop('choice of lattice constraint not recognized, are you using CVXR option by mistake')
  }
  return(y)
}