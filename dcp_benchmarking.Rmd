```{r}
library(stats)
library(dplyr)
library(ggplot2)
library(gurobi)
library(CVXR)
library(dplyr)
library(expm)
library(patchwork)
library(pracma)

construct_lattice=function(opts){
  min_dx  = opts$min_dx
  min_lat = opts$min_lat
  max_lat = opts$max_lat
  Nfine   = opts$Nfine
  
  L=matrix(NA,nrow=0,ncol=Nfine)
  for (npts in c(min_lat:max_lat)){
    dx = min_dx
    x0 = 1
    while (x0 + dx*(npts-1) <= Nfine){
      lat  = seq(from=x0,to=x0+dx*(npts-1),by=dx)
      shift = 0
      while (lat[length(lat)] + shift <= Nfine){
        lat       = lat + shift
        svec      = rep({0},Nfine)
        svec[lat] = 1 
        L         = rbind(L,svec)
        shift     = 1
      }
      dx = dx +1
    }
  }
  # TODO add pruning of L matrix
  return(t(L))
}


max_power_dcp = function(opts,costfun_type='L1',use_lattice=F){
# use DCP to maximize power over a range of frequencies 
  Nfine   = opts$Nfine
  Nfreq   = opts$Nfreq
  Nmeas   = opts$Nmeas
  fmin    = opts$fmin
  fmax    = opts$fmax
  
  tau   = (0:Nfine)/Nfine       
  tau   = tau[1:(length(tau)-1)] 
  fvec  = seq(from=fmin,to=fmax,length.out=Nfreq)
  
  # construct freq-discretized list of cfun matrices
  Amlist = list() 
  for (ii in c(1:Nfreq)){
    freq  = fvec[ii]
    cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
    svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
    
    a11   = cvec*cvec
    a22   = svec*svec
    a12   = cvec*svec
    Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
    
    Amlist[[ii]]=Amat
  }
   
  # choose whether or not to use a lattice
  if(use_lattice){
    L    = construct_lattice(opts) 
    Lnum = L
    w    = colSums(L)
    L    = Constant(L) # CVXR datatype
    w    = Constant(w) # CVXR datatype
    
    x            = Variable(dim(L)[2],boolean=T)
    constraints  = list( sum(x) == opts$max_lat_active, t(w)%*%x == Nmeas)#TODO decide on ineq or eq
   
    if (costfun_type == 'L1'){
      Amean = 0
      for (ii in c(1:Nfreq)){
        Amean = Amean +Amlist[[ii]]/Nfreq
      }
      Amean = Constant(t(Lnum)%*%Amean%*%Lnum)
      
    }
    else if (costfun_type=='Linfty'){
      for (ii in c(1:Nfreq)){
        Amlist[[ii]] = Constant(t(Lnum)%*%Amlist[[ii]]%*%Lnum)
      }
    }
  }else{
    x           = Variable(Nfine,boolean=T)
    constraints = list(sum(x)==Nmeas)
    if (costfun_type=='L1'){
      Amean = 0
      for (ii in c(1:Nfreq)){
        Amean = Amean + Amlist[[ii]]/Nfreq
      }
      Amean = Constant(Amean)
    } else if (costfun_type=='Linfty'){
      for (ii in c(1:Nfreq)){
        Amlist[[ii]] = Constant(Amlist[[ii]])
      }
      
    }
  }
  
  # parse Amlist to construct optimization prob
  if (costfun_type=='L1'){
    prob = Problem(Minimize(quad_form(x,Amean)),constraints)
  }else if(costfun_type=='Linfty'){
    big_str = paste(lapply(1:length(Amlist) %>% as.list(),
           function(ind){
             paste0('quad_form(x,Amlist[[',ind,']])')
           }),collapse=',')
    strp=paste0('prob=Problem(Minimize(max_elemwise(',big_str,')),constraints)')
    eval(parse(text=strp))
  }
  
  start=Sys.time()
  # solve optimization problem
  result       = solve(prob,verbose=opts$verbose,num_iter=opts$num_iter,MIPGapAbs=1e-2)
  end = Sys.time()
  end-start
  return(list(Lnum=Lnum,xopt=result[[1]]))
}

opts = list(  Nfine          = 144,
              Nfreq          = 10, 
              Nmeas          = 30, 
              fmin           = 1, 
              fmax           = 24, 
              min_dx         = 1, 
              min_lat        = 6, 
              max_lat        = 6, 
              max_lat_active = 5, 
              verbose        = T, 
              num_iter       = 1e8)
reslist=max_power_dcp(opts,costfun_type = 'L1',use_lattice = T)
```


```{r}
LL=list(val=5)

test = function(LL){
  attach(LL)
  return(val+1)
}
```