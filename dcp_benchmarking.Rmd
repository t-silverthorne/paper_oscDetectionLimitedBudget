```{r}
library(stats)
library(dplyr)
library(ggplot2)
library(gurobi)
library(CVXR)
library(dplyr)
library(expm)
library(patchwork)
library(pracma)

#opts = list(  Nfine          = ,
#              Nfreq          = , 
#              Nmeas          = , 
#              fmin           = , 
#              fmax           = , 
#              min_dx         = , 
#              min_lat        = , 
#              max_lat        = , 
#              max_lat_active = , 
#              verbose        = , 
#              num_iter       =)
construct_lattice=function(opts){
  min_dx  = opts$min_dx
  min_lat = opts$min_lat
  max_lat = opts$max_lat
  for (npts in c(min_lat:max_lat)){
    dx = min_dx
    x0 = 1
    while (x0 + dx*(npts-1) <= Nfine){
      lat  = seq(from=x0,to=x0+dx*(npts-1),by=dx)
      shift = 0
      while (lat[length(lat)] + shift <= Nfine){
        lat       = lat + shift
        svec      = rep({0},Nfine)
        svec[lat] = 1 
        L         = rbind(L,svec)
        shift     = 1
      }
      dx = dx +1
    }
  }
  # TODO add pruning of L matrix
  return(t(L))
}

max_power_dcp = function(opts,costfun_type,use_lattice){
# use DCP to maximize power over a range of frequencies 
  Nfine   = opts$Nfine
  Nfreq   = opts$Nfreq
  Nmeas   = opts$Nmeas
  fmin    = opts$fmin
  fmax    = opts$fmax
  
  # construct freq-discretized list of cfun matrices
  Amlist = list() 
  for (ii in c(1:Nfreq)){
    freq  = fvec[ii]
    cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
    svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
    
    a11   = cvec*cvec
    a22   = svec*svec
    a12   = cvec*svec
    Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
    
    Amlist[[ii]]=Amat
  }
   
  # choose whether or not to use a lattice
  if(use_lattice){
    L    = construct_lattice(opts) 
    Lnum = L
    w    = colSums(L)
    L    = Constant(L) # CVXR datatype
    w    = Constant(w) # CVXR datatype
    
    x            = Variable(dim(L)[2],boolean=T)
    constraints  = list( sum(x) == opts$max_lat_active, t(w)%*%x == Nmeas)#TODO decide on ineq or eq
   
    if (costfun_type=='Linfty'){
      for (ii in c(1:Nfreq)){
        Amlist[[ii]] = Constant(t(Lnum)%*%Amlist[[ii]]%*%Lnum)
      }
    }
  }else{
    x           = Variable(Nfine,boolean=T)
    constraints = list(sum(x)==Nmeas)
    if (costfun_type=='Linfty'){
      for (ii in c(1:Nfreq)){
        Amlist[[ii]] = Constant(Amlist[[ii]])
      }
    } 
  }
  
  # parse Amlist to construct optimization prob
  if (costfun_type=='L1'){
    
  }else if(costfun_type=='Linfty'){
    big_str = paste(lapply(1:length(Amlist) %>% as.list(),
           function(ind){
             paste0('Nmeas - quad_form(x,Amlist[[',ind,']])')
           }),collapse=',')
    strp=paste0('prob=Problem(Maximize(min_elemwise(',big_str,')),constraints)')
    eval(parse(text=strp))
  }
  
  # solve optimization problem
  result       = solve(prob,verbose=opts$verbose,num_iter=opts$num_iter)
}
```


```{r}
LL=list(val=5)

test = function(LL){
  attach(LL)
  return(val+1)
}
```