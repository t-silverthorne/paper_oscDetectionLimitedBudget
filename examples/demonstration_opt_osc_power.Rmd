# Overview
The purpose of this notebook is to illustrate how to use the solvers included in this package.

All solvers are accessed using the opt_osc_power wrapper. They are split into 
(1) Discrete versus continuous time
(2) Presence of lattice constraints

Item (1) is relevant if you only want to consider solutions that fall on a particular grid, for instance you cut a 24hr study into 5 minute intervals and only consider measurement times happening at those intervals.

Item (2) is relevant if you want to find near-optimal designs that can be decomposed into unions of uniform grids. This is convenient for experiments that want a balance between high statistical power with ease of implementation.
```{r}
library(devtools)
library(CVXR)
library(gurobi)
load_all()
#TODO: confirm control states are minimal (can remove instructions)
```


```{r}
Nmeas=16
Nfreq=2^8
freqs=seq(from=1,to=24,length.out=Nfreq)
maxit_global=10

#Nomenclature: cts/disc | lat/arb | bfgs/dcp/sa 
Amp_global=2
```
# Continuous time solvers

## No lattice constraints

Simplest choice of cost function. Each decision variable corresponds to a measurement time in the unit intevral [0,1]. Solver maximizes power either using gradient-based method L-BFGS-B or via simulated annealing.

The transition function for simulated annealing is Brownian motion on a torus, meaning that if a measurement time exits the left/right end-point of the interval, it reappears at the corresponding right/left endpoint. 
```{r}
# BFGS
dvar0   = c(1:Nmeas)/Nmeas - 1/Nmeas
control = list(costfun_choice='svdpower',
             optim_method='L-BFGS-B',
             trace=6,#normally 6 if you want output
             REPORT=1,
             maxit=2)
cts_arb_bfgs = opt_osc_power(dvar0=dvar0,freqs=freqs,control=control,Amp=Amp_global)

# simulated annealing
control$optim_method='simul_anneal'
control$tfun_choice='brownian-torus'
control$tfun_mean   = 0 
control$tfun_sd     = .1
cts_arb_sa   = opt_osc_power(dvar0=dvar0,freqs=freqs,control=control,Amp=Amp_global)
```

## With lattice constraints

Implementation of 2-lattice constraints: candidate solutions must be decomposable into a union of two uniform lattices. We parameterize the problem by specifying two uniform grids with points N1+N2=Nmeas, and then represent the state by the shift of grid2 relative to grid1 and the scale factor of each grid.

Since all three decision variables (two scales and one shift) are continuous, the problem can be studied using L-BFGS-B. We also include a simulated annealing routine with a custom transition function. Here, the state parameters are updated by perturbation from a uniform random variable on a window whose size is chosen to ensure the updated lattice does not exit the unit interval.
```{r}
# BFGS
control=list(costfun_choice='svdpower_2lattice',
             optim_method='L-BFGS-B',
             trace=6,
             REPORT=1,
             maxit=2)
lat1=c(1:8)/8 -1/8
lat2=lat1
x0=c(shift1=0,shift2=0.5,scale1=.5,scale2=.5)
xout=opt_osc_power(dvar0=list(x0=x0,lat1=lat1,lat2=lat2),freqs,Amp=Amp_global,control)

# simulated annealing
load_all()
control$optim_method          = 'simul_anneal'
control$maxit                 = 5
control$tfun_choice           = 'unif-with-bdry'
control$tscale_unif_with_bdry = 1/10
x0=c(shift1=0,shift2=0.5,scale1=.5,scale2=.5)
xout=opt_osc_power(dvar0=list(x0=x0,lat1=lat1,lat2=lat2),freqs,Amp=Amp_global,control)
expect_gt(xout$fvalue,0)
expect_lt(xout$fvalue,1)
```


# Discrete time solvers

## No lattice constraints

A uniform grid is constructed and fixed for the entire procedure. Then,

```{r}
# CVXR
load_all()
Nfine=2^7
control=list(costfun_choice='svdpower_discrete',
             optim_method='cvxr',
             trace=1,
             REPORT=1,
             maxit=1e9,time_limit=2,MIPGapAbs=.01,
             cvxr_verbose=T,
             costfun_type='Linfty',
             fmin=1,fmax=24,Nfreq=8,
             lattice_cstr='none',
             Nfine=Nfine,Nmeas=Nmeas)

xinds = sample(c(1:Nfine),Nmeas) 
tau=c(1:Nfine)/Nfine - 1/Nfine 
xout=opt_osc_power(dvar0=xinds,freqs=freqs,Amp=Amp_global,control=control,tau=tau)

# simulated annealing
control=list(costfun_choice='svdpower_discrete',
             optim_method='simul_anneal',
             tfun_choice='single-flip',
             trace=1,
             REPORT=1,
             maxit=50,
             fmin=1,fmax=24,Nfreq=2^10,
             Nfine=Nfine,Nmeas=Nmeas)
xout=opt_osc_power(dvar0=xinds,freqs=freqs,Amp=Amp_global,control=control,tau=tau)
```
## With lattice constraints

```{r}
# simulated annealing
Nfine=288
tau=c(1:Nfine)/Nfine - 1/Nfine 
freqs=seq(from=1,to=24,length.out=2^10)

dvar0=list(x0 = c(dx1=1,dx2=1,xshift2=Nfine/2),
N1      = 8,
N2      = 6)

control=list(costfun_choice = 'svdpower_2lattice_discrete',
             optim_method   = 'simul_anneal',
             tfun_choice    = 'unif-with-bdry-discrete',
             tscale         = 2,
             trace          = 6,
             REPORT         = 1,
             maxit          = 100)
xout=opt_osc_power(dvar0=dvar0,freqs=freqs,Amp=2,control=control,tau=tau)
```