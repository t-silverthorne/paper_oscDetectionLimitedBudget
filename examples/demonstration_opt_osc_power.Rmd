# Overview
The purpose of this notebook is to illustrate how to use the solvers included in this package.

All solvers are accessed using the opt_osc_power wrapper. They are split into 
(1) Discrete versus continuous time
(2) Presence of lattice constraints

Item (1) is relevant if you only want to consider solutions that fall on a particular grid, for instance you cut a 24hr study into 5 minute intervals and only consider measurement times happening at those intervals.

Item (2) is relevant if you want to find near-optimal designs that can be decomposed into unions of uniform grids. This is convenient for experiments that want a balance between high statistical power with ease of implementation.
```{r}
library(devtools)
library(CVXR)
library(gurobi)
load_all()
```


```{r}
Nmeas=16
Nfreq=2^8
freqs=seq(from=1,to=24,length.out=Nfreq)
maxit_global=10

#Nomenclature: cts/disc | lat/arb | bfgs/dcp/sa 
Amp_global=2
```
# Continuous time solvers

## No lattice constraints
```{r}
dvar0= c(1:Nmeas)/Nmeas - 1/Nmeas
control=list(costfun_choice='svdpower',
             optim_method='L-BFGS-B',
             trace=6,#normally 6 if you want output
             REPORT=1,
             maxit=maxit_global)
cts_arb_bfgs = opt_osc_power(dvar0=dvar0,freqs=freqs,control=control,Amp=Amp_global)

control$optim_method='simul_anneal'
control$tfun_choice='brownian'
control$tfun_mean   = 0 
control$tfun_sd     = .1
cts_arb_sa   = opt_osc_power(dvar0=dvar0,freqs=freqs,control=control,Amp=Amp_global)
```

## With lattice constraints
```{r}

```


# Discrete time solvers

## No lattice constraints

## With lattice constraints