# Setup
For defining uniform and 2-uniform measurement grids
```{r}
library(stats)
library(dplyr)
library(ggplot2)
library(gurobi)
library(CVXR)
library(dplyr)
library(expm)
getPower <- function(t,param,alpha=.05){
# give power of one-frequency cosinor model
  Amp    = param[['Amp']];
  freq   = param[['freq']];
  acro   = param[['acro']];
  N      = length(t)
  
  cvec   = Amp*cos(2*pi*freq*t-acro);
  lambda = as.numeric(t(cvec)%*%cvec)
  
  f0     = qf(p=1-alpha,df1=2,df2=N-3)
  return(1 - pf(q=f0,df1=2,df2=N-3,ncp=lambda))
}
getFIM <- function(t,param){
  Amp    = param[['Amp']];
  freq   = param[['freq']];
  acro   = param[['acro']];
  N      = length(t)
  
  Y = matrix(c(rep(1,length(t)),
           cos(2*pi*t),
           sin(2*pi*t)),
           nrow=3,byrow=T)

  Y %*% t(Y)
}
getReducedFIM <- function(t,param){
  Amp    = param[['Amp']];
  freq   = param[['freq']];
  acro   = param[['acro']];
  N      = length(t)
  
  Y = matrix(c(cos(2*pi*t),
           sin(2*pi*t)),
           nrow=2,byrow=T)
  Y %*% t(Y)
}
```

## Test CVXR


## Working test
Alternative parameterization
```{r}
n =1e2 
x            = Variable(n,boolean=T)

A            = matrix(rnorm(n*n),nrow=n,ncol=n)
#A            = t(A)%*%A
a11=matrix(rnorm(n),nrow=n)
a12=matrix(rnorm(n),nrow=n)
a22=matrix(rnorm(n),nrow=n)
a11=a11^2
a22=a22^2
#A=a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)

constraints  = list( sum(x) == 5)
objective    = t(a11+a22)%*%x - CVXR::norm2(A%*%x) 
prob         = Problem(Maximize(objective),constraints)
result       = solve(prob,verbose=F,num_iter=1e5)
result$status
result$getValue(x)
```

## Check DCP expression for lambda min
```{r}
library(CVXR)
library(gurobi)
library(expm)
freq=1
Amp=1

Nfine = 5 
Nmeas = 5


# generate sampling grid
#tau   = (0:Nfine)/Nfine       # equally spaced
tau   = runif(Nfine+1)         # uniformly random
tau   = tau[1:(length(tau)-1)] 

# evaluate model at sampling points
cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)

# reduced Fisher information matrix
x0=matrix(rep(1/Nfine,Nfine),nrow=Nfine)
tilX = cbind(cvec,svec)
tilM = t(tilX)%*%pracma::Diag(as.vector(x0))%*%tilX # reduced Fisher Information matrix

# vectors for constructing disciplined quadratic form
a11=cvec*cvec
a22=svec*svec
a12=cvec*svec

# compare disciplined quadratic form to direct computation of eigenvalue
lmin1 = min(eigen(tilM) %>% {.$values})
lmin2 = 0.5*(Trace(tilM) - sqrt(Trace(tilM)^2 - 4*det(tilM)))
bvec  = a11+a22
Amat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
A12   = Re(sqrtm(Amat))

# check that all three eigenvalue computations give same answer
lmin1 #eigenvalue
lmin2 #2x2 eigenvalue formula
0.5*(t(bvec)%*%x0 -sqrt(t(x0)%*%Amat%*%x0)) # directly evaluate form
0.5*(t(bvec)%*%x0 -Matrix::norm(A12%*%x0,type='2')) # use matrix sqrt to evaluate form
```

# Fig 1: Uniform vs optimal
## Line graph
```{r}
N     = 8
Nacro = 2^7

t = (0:N)/N  # Shifted by 1 from matlab
t = t[1:(length(t)-1)]

param = list(Amp  = 2,
             acro = pi,
             freq = 2.4)

acrovals = 2*pi*( 0:(Nacro+1)/(Nacro+1) )
acrovals = acrovals[1:length(acrovals)-1]
acrovals = matrix(acrovals)

freqvals = seq(from=3.5,to=4.4,by=.1) 

df<-data.frame(expand.grid(acro=acrovals,freq=freqvals)) %>% 
  apply(1,function(x){
  param[['freq']]  = x[['freq']]
  param[['acro']] = x[['acro']]
  return(c(freq=x[['freq']],acro=x[['acro']],power=getPower(t,param)))
  }) %>% t() %>% data.frame()
df %>% head()

df %>% ggplot(aes(x=acro,y=power,group=freq,color=freq))+geom_line()#+facet_wrap(~freq)
```

# Old

Try on actual optimization problem, no luck
```{r}

Nmeas=8
Nfine=1e2
freq=3.8
tau=(0:Nfine)/Nfine
tau=tau[1:(length(tau)-1)]

mu=CVXR::Variable(Nfine,boolean=T)
tilX=cbind(cos(2*pi*freq*tau),sin(2*pi*freq*tau))
tilX=CVXR::Parameter(Nfine,2,'tilX',value=tilX)
objective=CVXR::Minimize(CVXR::lambda_max(t(tilX)%*%CVXR::diag(mu)%*%tilX))
prob = CVXR::Problem(objective = objective,constraints=list(sum(mu)<=Nmeas))
CVXR::solve(prob,solver='GUROBI')

# force mu to be boolean

CVXR::lambda_min(t(X)%*%X)
```

Try simplified optimization problem  mu'*x + x' Sigma x with x boolean
```{r}
library(CVXR)
n  <- 1e1
# parameters
mu          <- matrix(abs(rnorm(n)), nrow = n)
mu2          <- matrix(abs(rnorm(n)), nrow = n)
Sigma       <- matrix(rnorm(n^2), nrow = n, ncol = n)
Sigma2       <- matrix(rnorm(n^2), nrow = n, ncol = n)
Sigma       <- t(Sigma) %*% Sigma
Sigma2       <- t(Sigma2) %*% Sigma2

# problem
x           <- Variable(n,boolean=T)
constraints <- list( sum(x) == 4)
objective   <- t(mu) %*% x + sqrt(1e3*t(mu2) %*% x - quad_form(x,Sigma2))
prob        <- Problem(Maximize(objective), constraints)
result      <- solve(prob)
result$getValue(x)
result$status
```

Closer to actual problem lambda_max( A diag(x) B )
```{r}
# size 
n = 3
d = 2
x            = Variable(n,boolean=T)

# parameters
A            = matrix(rnorm(n*d),nrow=d,ncol=n)
B            = matrix(rnorm(n*d),nrow=n,ncol=d)

# problem
constraints  = list( sum(x) == 1,x>=0,x<=1)
#objective    = lambda_min(A%*%CVXR::diag(x)%*%B)
objective    = x[1]+sqrt(x[2]+x[3])-sum(x)^2
prob         = Problem(Maximize(objective),constraints)
result       = solve(prob)
result$status
result$getValue(x)

plot(result$getValue(x))
```