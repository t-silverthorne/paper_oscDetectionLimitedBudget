
```{r}
require(devtools)
require(annmatrix)
require(stringr)
require(CVXR)
require(gurobi)
load_all()

# discretization parameters
Nfine        = 144      
Nfreq        = 47 
Nmeas        = 32 
fmin         = 1
fmax         = 24
tau          = c(1:Nfine)/Nfine -1/Nfine 
fvec         = seq(from=fmin,to=fmax,length.out=Nfreq)
threads_glob = 12
tlim_glob    = 60 

control=list(
  Nmeas=Nmeas,
  Nfine=Nfine,
  Nfreq=Nfreq,
  fmin=fmax,
  fmax=fmin,
  PreSolve=2,
  MIPFocus=3,
  cvxr_verbose=T,
  time_limit=tlim_glob,
  maxit=1e9,
  MIPGapAbs=1e-12,
  MIPGap=1e-5,
  NodefileStart=Inf
  )
```
# Solve using raw gurobi
```{r}

# construct gurobi model
model=list()
model$A          = matrix(c(rep(1,Nfine),0),nrow=1)
model$sense      = '='
model$rhs        = Nmeas
model$obj        = c(rep(0,Nfine),1)
model$modelsense = 'min'
model$modelname  = 'convex_cosinor_power'
model$vtype      = c(rep('B',Nfine),'C')

# quadratic constraints
model$quadcon=list()
for (ii in c(1:Nfreq)){
  freq  = fvec[ii]
  cvec  = matrix(cos(2*pi*freq*tau),nrow=Nfine)
  svec  = matrix(sin(2*pi*freq*tau),nrow=Nfine)
  
  a11   = cvec*cvec
  a22   = svec*svec
  a12   = cvec*svec
  
  qcmat  = a11%*%t(a11) + a22%*%t(a22) +4*a12%*%t(a12)-a11%*%t(a22) - a22%*%t(a11)
  qcmat  = cbind(rbind(qcmat,rep(0,Nfine)),rep(0,Nfine+1))
  qc     = c(rep(0,Nfine),-1)
  beta   = 0
  sense  = '<'
  model$quadcon[[ii]] = list(Qc=qcmat,q=qc,rhs=beta,sense=sense)
}

# gurobi settings
params = list(TimeLimit=tlim_glob,MIPGap=1e-5,
              Presolve=2,MIPFocus=3,NumericFocus=3,Threads=threads_glob)

# solve
res1=gurobi(model,params)
```
# Solve using CVXR wrapper
```{r}
res2=solve_cvxr_spt(control,Threads=threads_glob,
                   use_spt=F,
                   drts=NULL,
                   pads=NULL)

```

# Compare
```{r}
x1  = res1$x[1:Nfine]
mt1 = tau[as.logical(x1)]
mt2 = tau[as.logical(res2[[1]])]

freqs_dense=seq(1,24,length.out=2^10)
costfun_svdpower(mt1,freqs_dense,cfuntype ='ncp')
costfun_svdpower(mt2,freqs_dense,cfuntype ='ncp')
```