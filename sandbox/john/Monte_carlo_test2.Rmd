---
title: "Monte_Carlo_Test DEMO"
output: html_document
---

```{r sourcing functions}
source("generate_data.R")
```

```{r data_generation}
param <- c(1, 1, 0, pi) #mu, amp, phase, and period
Outer_loop <- 10
Nmeas <- 4

generate_data("gaussian", Outer_loop, Nmeas, param)
```

```{r generating_data_manual}
Outloop = 100
Amp     = 1
phase   = 3
period  = 24
Nmeas   = 24
mt      = c(1:Nmeas)/Nmeas -1/Nmeas
noiseType <- "negative binomial"

Xdat <- generate_data("gaussian", Outloop, Nmeas, 1, 10, amp, phase, period)
rowCosinor(Xdat, c(1:ncol(Xdat)))
```

Now, in each outer loop, we will perform permutations by randomly shuffling the sampling values of each feature. Here, we give an example by setting the size of the inner loop as 5: 

```{r Permutation}
library(pingers)

#Simulation of the first run of outer loop
permute_data <- data.frame(matrix(NA, nrow = 1, ncol = B + 1))
permute_data <- unname(permute_data)
pval <- rep(NA, O)

I = 5
for (i in 1:I){
  vec <- as.vector(t(data.frame(c(paste("perm_", i, sep = ""), t(shuffle(t(df_rf[1,1:B + 1])))))))
  permute_data <- rbind(permute_data, vec)
}

colnames(permute_data) <- colnames(df_rf)
permute_data <- permute_data[-c(1),]
rownames(permute_data) <- permute_data$IDs

for (i in 2:ncol(permute_data)) {
  permute_data[[i]] <- as.double(permute_data[[i]])
}

#Create a new column called 'feature' to plot in GGPlot
permute_data$feature <- rownames(permute_data)
#With 'long' format, we can separate the data by features so it is easier to see with GGPlot
permute_data_long <- melt(permute_data[,-1], id.vars = 'feature', variable.name = 'sample', value.name = 'value')

#Let us have a look at the dataset generated from this cleanup
permute_data_long

#Plot using the data
ggplot(permute_data_long, aes(x = sample, y = value, group = feature, color = feature)) +
  geom_line() + 
  geom_point() +
  theme_minimal() +
  labs(title = 'Random Permutations of original cosinor feature values', x = 'Sample Number (Time)', y = 'Value') +
  scale_color_discrete(name = "Feature") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

permute_data
```

```{r Permutation2}
#Alternative method to perform permutation
require(dplyr)
require(data.table)
require(simphony)
require(pingers)
require(pracma)

I=5

data <- rnorm(B)
data <- replicate(I,{data}) %>% t()
for (ii in c(1:I)){
  data[ii,] = data[ii,shuffle(data.frame(c(1:B)))]
}
```


```{r MC_Pow_i}
"
This chunk initializes the function MC_Pow_I and returns the Monte Carlo Power Estimation given:
1) Reformatted rhythmic data which fulfills the formatting requirements for DiscoRhythm (Denoted as DiscoData)
2) I: Size of the inner loop (Positive Integer)
"

MC_Pow_I <- function(DiscoData, I){
  pval <- rep(NA, O)
  
    for (o in 1:O){
      permute_data <- data.frame(matrix(NA, nrow = 1, ncol = B + 1))
      permute_data <- unname(permute_data)
      
      for (i in 1:I){
        "Remember, 'shuffle' shuffles by the row. In our case, we take one row at a time
        So, we need to transpose the row first to do the shufflling and transpose back to get the permuted value.
        "
        vec <- as.vector(t(data.frame(c(paste("perm_", i, sep = ""), t(shuffle(t(DiscoData[o, 1:B+1])))))))
        permute_data <- rbind(permute_data, vec) #Add this one iteration of permutation
      }
      
      #Reformat the data to DiscoRhythm requirement
      colnames(permute_data) <- colnames(DiscoData)
      permute_data <- permute_data[-c(1),]
      rownames(permute_data) <- permute_data$IDs
      
      #Ensures values are numeric
      for (i in 2:ncol(permute_data)) {
        permute_data[[i]] <- as.double(permute_data[[i]])
      }
      
      #Fit DiscoRhythm for this particular observation
      SE <- discoDFtoSE(permute_data)
      selectDataSE <- discoCheckInput(SE)
      
      discoODAres <- discoODAs(SE,
                               period= P,
                               method="CS",
                               ncores=1,
                               circular_t=FALSE)
      
      #Obtain p-value from each of the permutations
      new_p_val <- discoODAres$CS$pvalue
      
      #At this iteration, the entry gives the proportion of the p-value which is smaller than the current p-value
      pval[o] <- mean(new_p_val < data_p_val[o])
    }
  
return (1 - mean(pval))
}
```
Now, having constructed the function to calculate Monte Carlo Power Estimation given only the data and the size of inner loop, we can work to applying various inner loop sizes from the sample data generated earlier to calculate power under different inner loop sizes

```{r extrapolation}
ind = c(99, 79, 59, 39, 19) #As recommended by the paper
vec <- NULL
  
for (i in ind){
  vec <- append(vec, MC_Pow_I(df_rf, i))
}

pow <- data.frame(x = 1/ind,
                  y = vec)
```

```{r display_extrapolation}
data.frame("Inverse_of_the_size_of_inner_loop" = pow$x, "Monte_Carlo_power_estimate" = pow$y)
```
Now, we perform extrapolation by fitting a linear regression using OLS. Note that the Monte - Carlo estimate from extrapolation is the intercept coefficient of the OLS coefficient estimates.

```{r extrapolation_2}
lm <- lm(y ~ x + I(x^2), data = pow)
summary(lm)

ggplot(pow, aes(x = x, y = y)) +
  geom_line() + 
  geom_point() +
  theme_minimal() +
  labs(title = 'Power Estimation Across Distinct Inner Loop Sizes', x = '1 / (Size of Inner Loop)', y = 'Power Estimate')
```

```{r Final_Power}
library(pracma)

Sigma = 1
f = 1/P
phi = 0
alpha <- 0.05


calculate_lambda <- function(A, N, Sigma, phi, samp){
  summation <- sum(cos(2 * pi * f * (linspace(1, N,  n = samp) - phi))^2)
  return ((A^2 / (Sigma)) * summation)
}

calculate_gamma <- function(lambda, alpha) {
  F_central_inverse <- qf(1 - alpha, df1 = 2, df2 = P - 3)
  return (1 - pf(F_central_inverse, df1 = 2, df2 = P - 3, ncp = lambda))
}

l = calculate_lambda(A,P,Sigma,phi,B)

paste("The power of the test is: ", calculate_gamma(l, 0.05))
paste("Monte carlo Estimate is:", lm$coefficients[1])
```